<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'">
    <title>Docs4ai</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f5f7;
            color: #1d1d1f;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 560px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 24px;
            position: relative;
        }

        header h1 {
            font-size: 28px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .language-selector {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .language-selector select {
            padding: 6px 10px;
            border: 1px solid #d2d2d7;
            border-radius: 6px;
            font-size: 13px;
            background: white;
            cursor: pointer;
            color: #1d1d1f;
        }

        .language-selector select:focus {
            outline: none;
            border-color: #0071e3;
        }

        .language-selector label {
            font-size: 12px;
            color: #86868b;
            margin: 0;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            margin-top: 8px;
            color: #86868b;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff3b30;
        }

        .status-dot.active {
            background: #34c759;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .card-title {
            font-size: 13px;
            font-weight: 600;
            color: #86868b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .download-progress-card {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            border: 1px solid #90caf9;
        }

        .download-progress-info {
            font-size: 14px;
            color: #1565c0;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .download-progress-bar-container {
            height: 8px;
            background: rgba(255,255,255,0.7);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 6px;
        }

        .download-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #42a5f5, #7e57c2);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .download-progress-text {
            font-size: 12px;
            color: #5e35b1;
            text-align: center;
        }

        .input-group {
            margin-bottom: 12px;
        }

        .input-group:last-child {
            margin-bottom: 0;
        }

        .input-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        label {
            font-size: 14px;
            color: #1d1d1f;
            margin-bottom: 4px;
            display: block;
        }

        input[type="text"],
        input[type="password"] {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 14px;
            background: #fafafa;
        }

        input:focus {
            outline: none;
            border-color: #0071e3;
        }

        .path-display {
            flex: 1;
            padding: 10px 12px;
            background: #fafafa;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 13px;
            color: #86868b;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .path-display.has-value {
            color: #1d1d1f;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #e5e5ea;
            color: #1d1d1f;
        }

        .btn-primary {
            background: #0071e3;
            color: white;
        }

        .btn-primary:disabled {
            background: #86868b;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-danger {
            background: #ff3b30;
            color: white;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input {
            width: 18px;
            height: 18px;
        }

        .extensions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 8px;
            margin-top: 8px;
        }

        .extension-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 10px;
            background: #fafafa;
            border: 1px solid #e5e5ea;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            min-height: 38px;
        }

        .extension-checkbox:hover {
            background: #f0f0f0;
            border-color: #d2d2d7;
        }

        .extension-checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .extension-checkbox.checked {
            background: #e3f2fd;
            border-color: #0071e3;
        }

        .extension-label {
            cursor: pointer;
            user-select: none;
            flex: 1;
        }

        .extension-category {
            font-size: 11px;
            color: #86868b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 12px;
            margin-bottom: 6px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .extension-category:first-child {
            margin-top: 0;
        }

        .category-actions {
            display: flex;
            gap: 8px;
        }

        .category-action-btn {
            font-size: 10px;
            color: #0071e3;
            background: none;
            border: none;
            padding: 2px 6px;
            cursor: pointer;
            text-transform: none;
            letter-spacing: normal;
            font-weight: 500;
        }

        .category-action-btn:hover {
            text-decoration: underline;
            opacity: 1;
        }

        .extension-ext {
            color: #86868b;
            font-weight: normal;
            font-size: 11px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .stat-label {
            color: #86868b;
            font-size: 14px;
        }

        .stat-value {
            font-weight: 600;
            font-size: 14px;
        }

        .actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 8px;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 13px;
            color: #856404;
            margin-top: 8px;
        }

        .warning.error {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        input.error {
            border-color: #dc3545 !important;
            background: #fff5f5;
        }

        .info {
            font-size: 12px;
            color: #86868b;
            margin-top: 4px;
        }

        /* Modal styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 16px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e5ea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #86868b;
            padding: 0;
            line-height: 1;
        }

        .modal-close:hover {
            color: #1d1d1f;
        }

        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
        }

        .tree {
            list-style: none;
            padding-left: 0;
        }

        .tree ul {
            list-style: none;
            padding-left: 20px;
            margin: 0;
        }

        .tree-item {
            margin: 2px 0;
        }

        .tree-node {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.15s;
        }

        .tree-node:hover {
            background: #f0f0f0;
        }

        .tree-node.file:hover {
            background: #e8f4fd;
        }

        .tree-icon {
            margin-right: 6px;
            font-size: 14px;
            width: 18px;
            text-align: center;
        }

        .tree-label {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tree-count {
            color: #86868b;
            font-size: 12px;
            margin-left: 8px;
        }

        .tree-children {
            display: none;
        }

        .tree-children.expanded {
            display: block;
        }

        .tree-toggle {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 4px;
            font-size: 10px;
            color: #86868b;
        }

        .file-item {
            padding: 12px;
            border: 1px solid #e5e5ea;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-item:hover {
            background: #f5f5f7;
            border-color: #0071e3;
        }

        .file-name {
            font-weight: 500;
            font-size: 14px;
            word-break: break-all;
        }

        .file-meta {
            font-size: 12px;
            color: #86868b;
            margin-top: 4px;
        }

        .chunks-container {
            margin-top: 16px;
            border-top: 1px solid #e5e5ea;
            padding-top: 16px;
        }

        .chunks-header {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #1d1d1f;
        }

        .chunk-item {
            background: #f5f5f7;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .chunk-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
            color: #86868b;
        }

        .chunk-section {
            font-weight: 500;
            color: #0071e3;
        }

        .chunk-content {
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 150px;
            overflow-y: auto;
            background: white;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #e5e5ea;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
            font-size: 12px;
            line-height: 1.5;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #86868b;
        }

        .back-btn {
            background: none;
            border: none;
            color: #0071e3;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            margin-bottom: 12px;
        }

        .back-btn:hover {
            text-decoration: underline;
        }

        /* MCP Config Modal Styles */
        .mcp-tabs {
            display: flex;
            border-bottom: 1px solid #e5e5ea;
            background: #f5f5f7;
        }

        .mcp-tab {
            flex: 1;
            padding: 12px 8px;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-size: 13px;
            color: #86868b;
            transition: all 0.2s;
        }

        .mcp-tab:hover {
            color: #1d1d1f;
            background: rgba(0, 113, 227, 0.05);
        }

        .mcp-tab.active {
            color: #0071e3;
            border-bottom-color: #0071e3;
            background: white;
        }

        .mcp-panel {
            padding: 20px;
        }

        .mcp-panel p {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #1d1d1f;
        }

        .mcp-panel code {
            background: #f5f5f7;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
            font-size: 12px;
        }

        .mcp-code-block {
            position: relative;
            background: #1d1d1f;
            border-radius: 8px;
            padding: 16px;
            overflow: auto;
        }

        .mcp-code-block pre {
            margin: 0;
            color: #f5f5f7;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
            font-size: 12px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .mcp-copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #f5f5f7;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .mcp-copy-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .mcp-copy-btn.small {
            position: static;
            background: #0071e3;
            border: none;
            color: white;
            padding: 4px 8px;
            margin-left: 8px;
        }

        .mcp-info-row {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #f5f5f7;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .mcp-info-row .mcp-label {
            font-weight: 500;
            min-width: 80px;
            color: #86868b;
        }

        .mcp-info-row code {
            flex: 1;
            background: white;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #e5e5ea;
        }

        /* Profile tabs styles */
        .profile-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 16px;
            overflow-x: auto;
            padding-bottom: 4px;
        }

        .profile-tabs::-webkit-scrollbar {
            height: 4px;
        }

        .profile-tabs::-webkit-scrollbar-thumb {
            background: #d2d2d7;
            border-radius: 2px;
        }

        .profile-tab {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
            transition: all 0.2s;
            position: relative;
            user-select: none;
        }

        .profile-tab:hover {
            background: #f5f5f7;
            border-color: #0071e3;
        }

        .profile-tab.active {
            background: #0071e3;
            color: white;
            border-color: #0071e3;
        }

        .profile-tab .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #86868b;
        }

        .profile-tab.active .status-indicator {
            background: white;
        }

        .profile-tab.syncing .status-indicator {
            background: #34c759;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .profile-tab-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
            user-select: none;
            pointer-events: none;
        }

        .profile-tab-close {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            opacity: 0.6;
            transition: all 0.2s;
            font-size: 16px;
            line-height: 1;
        }

        .profile-tab:hover .profile-tab-close {
            opacity: 1;
            background: rgba(0, 0, 0, 0.1);
        }

        .profile-tab.active .profile-tab-close {
            opacity: 0.8;
        }

        .profile-tab.active:hover .profile-tab-close {
            background: rgba(255, 255, 255, 0.2);
        }

        .profile-tab-add {
            padding: 8px 12px;
            background: #e5e5ea;
            border: 1px dashed #86868b;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            color: #86868b;
            transition: all 0.2s;
            min-width: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .profile-tab-add:hover {
            background: #d2d2d7;
            border-color: #0071e3;
            color: #0071e3;
        }

        .profile-content {
            display: none;
        }

        .profile-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="language-selector">
                <label for="languageSelect">üåê</label>
                <select id="languageSelect">
                    <option value="en">English</option>
                    <option value="fr">Fran√ßais</option>
                    <option value="es">Espa√±ol</option>
                    <option value="zh">‰∏≠Êñá</option>
                    <option value="hi">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</option>
                    <option value="ar">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
                    <option value="de">Deutsch</option>
                    <option value="it">Italiano</option>
                    <option value="pt">Portugu√™s</option>
                </select>
            </div>
            <h1>üìÑ Docs4ai</h1>
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Not syncing</span>
            </div>
        </header>

        <!-- Profile Tabs -->
        <div class="profile-tabs" id="profileTabs"></div>

        <!-- Profile Content Container -->
        <div id="profileContentContainer">
            <!-- Content will be dynamically generated for each profile -->
        </div>

        <!-- MCP Server Card (shared across profiles) -->
        <div class="card" style="margin-top: 16px;">
            <div class="card-title">üåê MCP Server</div>
            
            <div class="input-group">
                <div class="input-row">
                    <label for="mcpPort" style="margin: 0; white-space: nowrap;">Port:</label>
                    <input type="text" id="mcpPort" value="3333" style="width: 80px;">
                    <button class="btn-secondary" id="mcpToggleBtn" onclick="toggleMcpServer()">Start Server</button>
                </div>
            </div>
            
            <div id="mcpStatus" class="info" style="margin-top: 8px;">
                Server stopped
            </div>
            
            <button class="btn-secondary" id="mcpConfigureBtn" style="display: none; width: 100%; margin-top: 8px;" onclick="openMcpConfig()">Configure Clients</button>
        </div>
    </div>

    <!-- Browse Database Modal -->
    <div class="modal-overlay" id="browserModal">
        <div class="modal">
            <div class="modal-header">
                <h2 id="modalTitle">üìÇ Browse Database</h2>
                <button class="modal-close" onclick="closeBrowser()">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
                <div class="empty-state">Loading...</div>
            </div>
        </div>
    </div>

    <!-- Input Dialog Modal -->
    <div class="modal-overlay" id="inputDialogModal">
        <div class="modal" style="max-width: 400px;">
            <div class="modal-header">
                <h2 id="inputDialogTitle">Enter Name</h2>
                <button class="modal-close" onclick="closeInputDialog()">&times;</button>
            </div>
            <div class="modal-body">
                <label for="inputDialogInput" style="display: block; margin-bottom: 8px; font-size: 14px;" id="inputDialogMessage">Name:</label>
                <input type="text" id="inputDialogInput" style="width: 100%; padding: 10px 12px; border: 1px solid #d2d2d7; border-radius: 8px; font-size: 14px;" autofocus>
                <div style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px;">
                    <button class="btn-secondary" onclick="closeInputDialog()">Cancel</button>
                    <button class="btn-primary" onclick="confirmInputDialog()">OK</button>
                </div>
            </div>
        </div>
    </div>

    <!-- MCP Configuration Modal -->
    <div class="modal-overlay" id="mcpConfigModal">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header">
                <h2>üîå Configure MCP Client</h2>
                <button class="modal-close" onclick="closeMcpConfig()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 0;">
                <!-- Tabs -->
                <div class="mcp-tabs">
                    <button class="mcp-tab active" data-tab="cursor" onclick="switchMcpTab('cursor')">Cursor</button>
                    <button class="mcp-tab" data-tab="vscode" onclick="switchMcpTab('vscode')">VS Code</button>
                    <button class="mcp-tab" data-tab="claude" onclick="switchMcpTab('claude')">Claude Code</button>
                    <button class="mcp-tab" data-tab="chatgpt" onclick="switchMcpTab('chatgpt')">ChatGPT</button>
                    <button class="mcp-tab" data-tab="other" onclick="switchMcpTab('other')">Other</button>
                </div>
                
                <!-- Tab Content -->
                <div class="mcp-tab-content" id="mcpTabContent">
                    <!-- Cursor -->
                    <div class="mcp-panel" id="panel-cursor">
                        <p>Add the following to your <code>~/.cursor/mcp.json</code> file:</p>
                        <div class="mcp-code-block">
                            <pre id="cursorConfig"></pre>
                            <button class="mcp-copy-btn" onclick="copyConfig('cursor')">Copy</button>
                        </div>
                    </div>
                    
                    <!-- VS Code -->
                    <div class="mcp-panel" id="panel-vscode" style="display: none;">
                        <p>Add the following to your VS Code settings or MCP extension config:</p>
                        <div class="mcp-code-block">
                            <pre id="vscodeConfig"></pre>
                            <button class="mcp-copy-btn" onclick="copyConfig('vscode')">Copy</button>
                        </div>
                    </div>
                    
                    <!-- Claude Code -->
                    <div class="mcp-panel" id="panel-claude" style="display: none;">
                        <p>Add the following to your Claude Code MCP configuration:</p>
                        <div class="mcp-code-block">
                            <pre id="claudeConfig"></pre>
                            <button class="mcp-copy-btn" onclick="copyConfig('claude')">Copy</button>
                        </div>
                    </div>
                    
                    <!-- ChatGPT -->
                    <div class="mcp-panel" id="panel-chatgpt" style="display: none;">
                        <p>ChatGPT desktop app supports MCP servers. Configure in settings:</p>
                        <div class="mcp-code-block">
                            <pre id="chatgptConfig"></pre>
                            <button class="mcp-copy-btn" onclick="copyConfig('chatgpt')">Copy</button>
                        </div>
                    </div>
                    
                    <!-- Other -->
                    <div class="mcp-panel" id="panel-other" style="display: none;">
                        <p>For other MCP-compatible clients, use these settings:</p>
                        <div class="mcp-info-row">
                            <span class="mcp-label">URL:</span>
                            <code id="mcpUrl"></code>
                            <button class="mcp-copy-btn small" onclick="copyText('mcpUrl')">Copy</button>
                        </div>
                        <div class="mcp-info-row">
                            <span class="mcp-label">Transport:</span>
                            <code>Streamable HTTP</code>
                        </div>
                        <div class="mcp-info-row">
                            <span class="mcp-label">Protocol:</span>
                            <code>MCP 2024-11-05</code>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let profiles = [];
        let activeProfileId = null;
        let profileStats = new Map();
        let mcpRunning = false;
        let saveSettingsTimers = new Map(); // Debounce timers for profile settings

        // Load profiles on startup
        async function loadProfiles() {
            const data = await window.api.getProfiles();
            profiles = data.profiles || [];
            activeProfileId = data.activeProfileId;
            
            // If no profiles exist, create a default one
            if (profiles.length === 0) {
                const defaultProfile = await window.api.createProfile('Default Profile');
                profiles = [defaultProfile];
                activeProfileId = defaultProfile.id;
            } else if (!activeProfileId && profiles.length > 0) {
                activeProfileId = profiles[0].id;
                await window.api.setActiveProfile(activeProfileId);
            }
            
            renderTabs();
            await renderActiveProfile();
            
            // Get initial stats for all profiles
            for (const profile of profiles) {
                const stats = await window.api.getStats(profile.id);
                profileStats.set(profile.id, stats);
            }
            updateOverallStatus();
        }

        function renderTabs() {
            const tabsContainer = document.getElementById('profileTabs');
            if (!tabsContainer) {
                console.error('profileTabs container not found');
                return;
            }
            tabsContainer.innerHTML = '';
            
            for (const profile of profiles) {
                const tab = document.createElement('div');
                tab.className = `profile-tab ${profile.id === activeProfileId ? 'active' : ''}`;
                const stats = profileStats.get(profile.id) || { isSyncing: false };
                if (stats.isSyncing) {
                    tab.classList.add('syncing');
                }
                
                tab.innerHTML = `
                    <div class="status-indicator"></div>
                    <span class="profile-tab-name" title="${escapeHtml(profile.name)}">${escapeHtml(profile.name)}</span>
                    <span class="profile-tab-close" onclick="deleteProfile('${profile.id}', event)">&times;</span>
                `;
                
                tab.onclick = (e) => {
                    // Only prevent switching if clicking the close button
                    if (!e.target.classList.contains('profile-tab-close')) {
                        switchProfile(profile.id);
                    }
                };
                
                tabsContainer.appendChild(tab);
            }
            
            // Add button
            const addBtn = document.createElement('div');
            addBtn.className = 'profile-tab-add';
            addBtn.innerHTML = '+';
            addBtn.style.cursor = 'pointer';
            addBtn.title = t('ui.addNewProfile');
            addBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                e.preventDefault();
                console.log('Add button clicked');
                await createNewProfile();
            });
            tabsContainer.appendChild(addBtn);
            console.log('Tabs rendered, add button created');
        }

        // Input dialog functions
        let inputDialogResolve = null;
        let inputDialogReject = null;

        function showInputDialog(title, message, defaultValue = '') {
            return new Promise((resolve, reject) => {
                inputDialogResolve = resolve;
                inputDialogReject = reject;
                
                document.getElementById('inputDialogTitle').textContent = title;
                document.getElementById('inputDialogMessage').textContent = message;
                const input = document.getElementById('inputDialogInput');
                input.value = defaultValue;
                document.getElementById('inputDialogModal').classList.add('active');
                
                // Handle Enter key - remove old handler first
                const handleKeyDown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        e.stopPropagation();
                        input.removeEventListener('keydown', handleKeyDown);
                        confirmInputDialog();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        e.stopPropagation();
                        input.removeEventListener('keydown', handleKeyDown);
                        closeInputDialog();
                    }
                };
                
                // Remove any existing handler and add new one
                input.onkeydown = null;
                input.addEventListener('keydown', handleKeyDown);
                
                // Focus and select text
                setTimeout(() => {
                    input.focus();
                    input.select();
                }, 100);
            });
        }

        function confirmInputDialog() {
            const input = document.getElementById('inputDialogInput');
            const value = input.value.trim();
            
            // Resolve the promise first
            if (inputDialogResolve) {
                const resolve = inputDialogResolve;
                inputDialogResolve = null;
                inputDialogReject = null;
                // Close modal
                document.getElementById('inputDialogModal').classList.remove('active');
                // Resolve with the value
                resolve(value);
            }
        }

        function closeInputDialog() {
            // Reject the promise if it exists (user cancelled)
            if (inputDialogReject) {
                const reject = inputDialogReject;
                inputDialogResolve = null;
                inputDialogReject = null;
                document.getElementById('inputDialogModal').classList.remove('active');
                reject(null);
            } else {
                // Just close if no promise pending
                document.getElementById('inputDialogModal').classList.remove('active');
            }
        }

        async function createNewProfile() {
            try {
                console.log('createNewProfile called');
                const name = await showInputDialog(t('ui.newProfile'), t('ui.enterProfileName'), `${t('profile.name')} ${profiles.length + 1}`);
                console.log('User entered name:', name);
                
                if (!name) {
                    console.log('User cancelled or no name provided');
                    return;
                }
                
                if (!name.trim()) {
                    alert(t('ui.profileNameCannotBeEmpty'));
                    return;
                }
                
                console.log('Calling window.api.createProfile with name:', name.trim());
                
                try {
                    const newProfile = await window.api.createProfile(name.trim());
                    console.log('Received profile from API:', newProfile);
                    
                    if (!newProfile || !newProfile.id) {
                        console.error('Invalid profile returned:', newProfile);
                        alert('Failed to create profile: Invalid response from server');
                        return;
                    }
                    
                    console.log('Adding profile to local array');
                    profiles.push(newProfile);
                    activeProfileId = newProfile.id;
                    
                    console.log('Setting active profile:', activeProfileId);
                    await window.api.setActiveProfile(activeProfileId);
                    
                    profileStats.set(newProfile.id, { isSyncing: false, trackedFiles: 0, totalChunks: 0 });
                    
                    console.log('Rendering tabs and profile');
                renderTabs();
                await renderActiveProfile();
                console.log('Profile created successfully:', newProfile.name);
                } catch (apiError) {
                    console.error('API error creating profile:', apiError);
                    alert('Error creating profile: ' + (apiError.message || apiError));
                }
            } catch (error) {
                console.error('Error in createNewProfile:', error);
                alert('Error creating profile: ' + (error.message || error));
            }
        }


        async function deleteProfile(profileId, event) {
            event.stopPropagation();
            
            if (profiles.length === 1) {
                alert(t('ui.cannotDeleteLastProfile'));
                return;
            }
            
            if (!confirm(t('ui.deleteProfileConfirm'))) {
                return;
            }
            
            await window.api.deleteProfile(profileId);
            profiles = profiles.filter(p => p.id !== profileId);
            profileStats.delete(profileId);
            
            if (activeProfileId === profileId) {
                activeProfileId = profiles.length > 0 ? profiles[0].id : null;
                if (activeProfileId) {
                    await window.api.setActiveProfile(activeProfileId);
                }
            }
            
            renderTabs();
            await renderActiveProfile();
        }

        async function switchProfile(profileId) {
            activeProfileId = profileId;
            await window.api.setActiveProfile(profileId);
            renderTabs();
            await renderActiveProfile();
        }

        function populateExtensionCheckboxes(profileId, selectedExtensions) {
            const container = document.getElementById(`extensionsSelector-${profileId}`);
            if (!container) return;

            // Parse selected extensions
            const selected = selectedExtensions.split(',').map(e => e.trim()).filter(e => e);

            // Define all supported extensions grouped by category
            const extensionGroups = [
                {
                    category: 'Documents',
                    id: 'documents',
                    extensions: [
                        { ext: '.md', label: 'Markdown' },
                        { ext: '.txt', label: 'Text' },
                        { ext: '.pdf', label: 'PDF' },
                        { ext: '.doc', label: 'Word 97-2003' },
                        { ext: '.docx', label: 'Word' },
                        { ext: '.odt', label: 'OpenDocument' },
                        { ext: '.rtf', label: 'Rich Text' },
                        { ext: '.pptx', label: 'PowerPoint' }
                    ]
                },
                {
                    category: 'Web',
                    id: 'web',
                    extensions: [
                        { ext: '.html', label: 'HTML' },
                        { ext: '.htm', label: 'HTM' }
                    ]
                }
            ];

            // Build the HTML
            let html = '';
            for (const group of extensionGroups) {
                html += `
                    <div class="extension-category">
                        <span>${group.category}</span>
                        <div class="category-actions">
                            <button class="category-action-btn" onclick="selectAllExtensions('${profileId}', '${group.id}')">Select All</button>
                            <button class="category-action-btn" onclick="clearAllExtensions('${profileId}', '${group.id}')">Clear</button>
                        </div>
                    </div>
                `;
                html += `<div class="extensions-grid" data-category="${group.id}">`;
                for (const item of group.extensions) {
                    const isChecked = selected.includes(item.ext);
                    html += `
                        <label class="extension-checkbox ${isChecked ? 'checked' : ''}" data-ext="${item.ext}" data-category="${group.id}">
                            <input type="checkbox" value="${item.ext}" ${isChecked ? 'checked' : ''} onchange="handleExtensionChange('${profileId}', this)">
                            <span class="extension-label">${item.label} <span class="extension-ext">(${item.ext})</span></span>
                        </label>
                    `;
                }
                html += `</div>`;
            }

            container.innerHTML = html;
        }

        function selectAllExtensions(profileId, categoryId) {
            const checkboxes = document.querySelectorAll(`#extensionsSelector-${profileId} .extension-checkbox[data-category="${categoryId}"] input[type="checkbox"]`);
            checkboxes.forEach(cb => {
                if (!cb.checked) {
                    cb.checked = true;
                    cb.closest('.extension-checkbox').classList.add('checked');
                }
            });
            debouncedSaveProfileSettings(profileId);
        }

        function clearAllExtensions(profileId, categoryId) {
            const checkboxes = document.querySelectorAll(`#extensionsSelector-${profileId} .extension-checkbox[data-category="${categoryId}"] input[type="checkbox"]`);
            checkboxes.forEach(cb => {
                if (cb.checked) {
                    cb.checked = false;
                    cb.closest('.extension-checkbox').classList.remove('checked');
                }
            });
            debouncedSaveProfileSettings(profileId);
        }

        function handleExtensionChange(profileId, checkbox) {
            // Update the label styling
            const label = checkbox.closest('.extension-checkbox');
            if (checkbox.checked) {
                label.classList.add('checked');
            } else {
                label.classList.remove('checked');
            }

            // Save settings with debounce
            debouncedSaveProfileSettings(profileId);
        }

        function debouncedSaveProfileSettings(profileId) {
            // Clear existing timer for this profile
            if (saveSettingsTimers.has(profileId)) {
                clearTimeout(saveSettingsTimers.get(profileId));
            }

            // Set new timer - save after 500ms of no changes
            const timer = setTimeout(() => {
                saveProfileSettings(profileId);
                saveSettingsTimers.delete(profileId);
            }, 500);

            saveSettingsTimers.set(profileId, timer);
        }

        async function renderActiveProfile() {
            const container = document.getElementById('profileContentContainer');
            const profile = profiles.find(p => p.id === activeProfileId);
            
            if (!profile) {
                container.innerHTML = `<div class="empty-state">${t('ui.noProfileSelected')}</div>`;
                return;
            }
            
            const stats = profileStats.get(profile.id) || { isSyncing: false, trackedFiles: 0, totalChunks: 0 };
            
            container.innerHTML = `
                <div class="profile-content active" data-profile-id="${profile.id}">
                    <div class="card">
                        <div class="card-title">üë§ ${t('profile.name')}</div>
                        <div class="input-group">
                            <input type="text" id="profileName-${profile.id}" value="${escapeHtml(profile.name)}" placeholder="${t('profile.name')}" style="width: 100%; padding: 10px 12px; border: 1px solid #d2d2d7; border-radius: 8px; font-size: 14px;">
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-title">üìÅ ${t('profile.watchedFolder')}</div>
                        <div class="input-row">
                            <div class="path-display ${profile.watchedFolder ? 'has-value' : ''}" id="folderPath-${profile.id}">${profile.watchedFolder || t('ui.noFolderSelected')}</div>
                            <button class="btn-secondary" id="selectFolderBtn-${profile.id}">${t('profile.selectFolder')}</button>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-title">üíæ ${t('profile.databasePath')}</div>
                        <div class="input-row">
                            <div class="path-display ${profile.databasePath ? 'has-value' : ''}" id="databasePath-${profile.id}">${profile.databasePath || t('ui.noDatabaseSelected')}</div>
                            <button class="btn-secondary" id="selectDatabaseBtn-${profile.id}">${t('profile.selectDatabase')}</button>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-title">‚öôÔ∏è ${t('profile.settings', {})}</div>
                        
                        <div class="input-group">
                            <div class="checkbox-group">
                                <input type="checkbox" id="recursive-${profile.id}" ${profile.recursive ? 'checked' : ''}>
                                <label for="recursive-${profile.id}">${t('ui.watchSubdirectories')}</label>
                            </div>
                        </div>

                        <div class="input-group">
                            <label>${t('ui.fileExtensions')}:</label>
                            <div id="extensionsSelector-${profile.id}">
                                <!-- Extensions will be populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-title">üß† ${t('profile.embeddings', {})}</div>
                        
                        <div class="input-group">
                            <label for="embeddingProvider-${profile.id}">${t('ui.embeddingProvider')}:</label>
                            <select id="embeddingProvider-${profile.id}" style="width: 100%; padding: 10px 12px; border: 1px solid #d2d2d7; border-radius: 8px; font-size: 14px; background: white;">
                                <option value="local-minilm" ${profile.embeddingProvider === 'local-minilm' ? 'selected' : ''}>${t('ui.localMinilm')} (${t('ui.free')})</option>
                                <option value="local-e5" ${profile.embeddingProvider === 'local-e5' || profile.embeddingProvider === 'local-qwen' ? 'selected' : ''}>${t('ui.localE5')} (${t('ui.free')})</option>
                                <option value="local-e5-large" ${(profile.embeddingProvider || 'local-e5-large') === 'local-e5-large' ? 'selected' : ''}>${t('ui.localE5Large')} (${t('ui.free')})</option>
                                <option value="openai" ${profile.embeddingProvider === 'openai' ? 'selected' : ''}>${t('ui.openaiEmbeddings')} (${t('ui.paid')})</option>
                            </select>
                            <div class="model-description" id="modelDescription-${profile.id}" style="margin-top: 6px; font-size: 12px; color: #666;">
                                ${getModelDescription(profile.embeddingProvider || 'local-e5-large')}
                            </div>
                        </div>
                        
                        <div class="input-group" id="apiKeyGroup-${profile.id}" style="display: ${profile.embeddingProvider === 'openai' ? 'block' : 'none'};">
                            <label for="apiKey-${profile.id}">${t('ui.apiKey')}:</label>
                            <input type="password" id="apiKey-${profile.id}" value="${escapeHtml(profile.openAIApiKey || '')}" placeholder="sk-...">
                        </div>

                        <div class="info" id="embeddingInfo-${profile.id}">${profile.embeddingProvider === 'openai' ? t('ui.usesEmbedding') : t('ui.localEmbeddingInfo')}</div>
                        <div class="warning" id="apiKeyWarning-${profile.id}" style="display: none;">
                            ${t('ui.apiKeyRequired')}
                        </div>
                    </div>

                    <div class="card download-progress-card" id="downloadProgress-${profile.id}" style="display: none;">
                        <div class="card-title">‚¨áÔ∏è ${t('ui.downloadingModel')}</div>
                        <div class="download-progress-info">
                            <span id="downloadModelName-${profile.id}"></span>
                        </div>
                        <div class="download-progress-bar-container">
                            <div class="download-progress-bar" id="downloadProgressBar-${profile.id}" style="width: 0%"></div>
                        </div>
                        <div class="download-progress-text" id="downloadProgressText-${profile.id}"></div>
                    </div>

                    <div class="card" id="syncProgressCard-${profile.id}" style="display: ${stats.isSyncing && stats.syncProgress?.totalFiles > 0 ? 'block' : 'none'};">
                        <div class="card-title">üîÑ ${t('ui.syncProgress')}</div>
                        <div class="sync-progress-info" style="font-size: 14px; color: #1d1d1f; margin-bottom: 8px;">
                            <span id="syncProgressText-${profile.id}">0 / 0</span>
                        </div>
                        <div class="sync-progress-bar-container" style="height: 8px; background: #e5e5ea; border-radius: 4px; overflow: hidden; margin-bottom: 6px;">
                            <div class="sync-progress-bar" id="syncProgressBar-${profile.id}" style="height: 100%; background: #34c759; border-radius: 4px; transition: width 0.3s ease; width: 0%"></div>
                        </div>
                        <div class="sync-progress-percent" id="syncProgressPercent-${profile.id}" style="font-size: 12px; color: #86868b; text-align: center;">0%</div>
                    </div>

                    <div class="card">
                        <div class="card-title">üìä ${t('profile.stats', {})}</div>
                        
                        <div class="stat-item">
                            <span class="stat-label">${t('ui.filesTracked')}</span>
                            <span class="stat-value" id="trackedFiles-${profile.id}">${stats.trackedFiles || 0}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">${t('ui.totalChunks')}</span>
                            <span class="stat-value" id="totalChunks-${profile.id}">${stats.totalChunks || 0}</span>
                        </div>
                        <div class="stat-item" id="tokensRow-${profile.id}" style="display: ${profile.embeddingProvider === 'openai' ? 'flex' : 'none'};">
                            <span class="stat-label">${t('ui.totalTokens')}</span>
                            <span class="stat-value" id="totalTokens-${profile.id}">${(stats.totalTokens || 0).toLocaleString()}</span>
                        </div>
                        <div class="stat-item" id="costRow-${profile.id}" style="display: ${profile.embeddingProvider === 'openai' ? 'flex' : 'none'};">
                            <span class="stat-label">${t('ui.totalCost')}</span>
                            <span class="stat-value" id="totalCost-${profile.id}">$${(stats.totalCost || 0).toFixed(4)}</span>
                        </div>
                        <button class="btn-secondary" style="width: 100%; margin-top: 12px;" id="browseDbBtn-${profile.id}">${t('ui.browseDatabase')}</button>
                    </div>

                    <div class="actions">
                        <button class="btn-primary ${stats.isSyncing ? 'btn-danger' : ''}" id="startBtn-${profile.id}">${stats.isSyncing ? t('ui.stopSync') : t('ui.startSyncing')}</button>
                    </div>
                </div>
            `;

            // Populate extension checkboxes
            populateExtensionCheckboxes(profile.id, profile.fileExtensions);

            // Setup event listeners for this profile
            setupProfileListeners(profile.id);
            updateApiKeyWarning(profile.id);
            
            // Load MCP status for this profile
            if (activeProfileId === profile.id) {
                await loadMcpStatus();
            }
        }

        function setupProfileListeners(profileId) {
            const profileNameInput = document.getElementById(`profileName-${profileId}`);
            const apiKeyInput = document.getElementById(`apiKey-${profileId}`);
            const recursiveInput = document.getElementById(`recursive-${profileId}`);
            const selectFolderBtn = document.getElementById(`selectFolderBtn-${profileId}`);
            const selectDatabaseBtn = document.getElementById(`selectDatabaseBtn-${profileId}`);
            const browseDbBtn = document.getElementById(`browseDbBtn-${profileId}`);
            const startBtn = document.getElementById(`startBtn-${profileId}`);
            const embeddingProviderSelect = document.getElementById(`embeddingProvider-${profileId}`);
            
            if (profileNameInput) {
                // Save on blur (when user finishes editing)
                profileNameInput.addEventListener('blur', async () => {
                    const newName = profileNameInput.value.trim();
                    if (newName && newName !== '') {
                        const profile = profiles.find(p => p.id === profileId);
                        if (profile && profile.name !== newName) {
                            await window.api.updateProfile(profileId, { name: newName });
                            profile.name = newName;
                            renderTabs(); // Update tab name
                        }
                    } else {
                        // Restore original name if empty
                        const profile = profiles.find(p => p.id === profileId);
                        if (profile) {
                            profileNameInput.value = profile.name;
                        }
                    }
                });
                
                // Also save on Enter key
                profileNameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        profileNameInput.blur();
                    }
                });
            }
            
            if (apiKeyInput) {
                apiKeyInput.addEventListener('input', () => {
                    apiKeyInput.classList.remove('error');
                    const warning = document.getElementById(`apiKeyWarning-${profileId}`);
                    if (warning) {
                        warning.classList.remove('error');
                        warning.textContent = t('ui.apiKeyRequired');
                    }
                    updateApiKeyWarning(profileId);
                    saveProfileSettings(profileId);
                });
            }

            if (recursiveInput) {
                recursiveInput.addEventListener('change', () => saveProfileSettings(profileId));
            }
            
            if (embeddingProviderSelect) {
                embeddingProviderSelect.addEventListener('change', async (e) => {
                    const newProvider = embeddingProviderSelect.value;
                    const profile = profiles.find(p => p.id === profileId);
                    const oldProvider = profile?.embeddingProvider || 'local-e5-large';
                    
                    // If provider actually changed, warn user about database reset
                    if (oldProvider !== newProvider) {
                        const stats = profileStats.get(profileId) || { isSyncing: false };
                        
                        // Build confirmation message
                        let confirmMsg = t('ui.embeddingProviderChangeWarning');
                        if (stats.isSyncing) {
                            confirmMsg += '\n\n' + t('ui.syncWillBeStopped');
                        }
                        
                        if (!confirm(confirmMsg)) {
                            // User cancelled - revert selection
                            embeddingProviderSelect.value = oldProvider;
                            return;
                        }
                        
                        // Stop sync if running
                        if (stats.isSyncing) {
                            await window.api.stopWatching(profileId);
                        }
                        
                        // Update the profile in the local profiles array so saveProfileSettings uses the new value
                        if (profile) {
                            profile.embeddingProvider = newProvider;
                        }
                        
                        // Save profile settings FIRST with new provider so database uses correct dimension
                        await saveProfileSettings(profileId);
                        
                        // Then clear the database
                        if (profile?.databasePath) {
                            await window.api.clearDatabase(profileId);
                        }
                        
                        // Reset stats to reflect cleared database
                        const resetStats = {
                            profileId,
                            isSyncing: false,
                            trackedFiles: 0,
                            totalChunks: 0,
                            totalTokens: 0,
                            totalCost: 0,
                            embeddingProvider: newProvider
                        };
                        updateStats(resetStats);
                        
                        // Also directly update the token/cost display elements
                        const tokensEl = document.getElementById(`totalTokens-${profileId}`);
                        const costEl = document.getElementById(`totalCost-${profileId}`);
                        if (tokensEl) tokensEl.textContent = '0';
                        if (costEl) costEl.textContent = '$0.0000';
                    }
                    
                    const apiKeyGroup = document.getElementById(`apiKeyGroup-${profileId}`);
                    const embeddingInfo = document.getElementById(`embeddingInfo-${profileId}`);
                    const tokensRow = document.getElementById(`tokensRow-${profileId}`);
                    const costRow = document.getElementById(`costRow-${profileId}`);
                    const modelDescription = document.getElementById(`modelDescription-${profileId}`);
                    
                    if (apiKeyGroup) {
                        apiKeyGroup.style.display = newProvider === 'openai' ? 'block' : 'none';
                    }
                    if (embeddingInfo) {
                        embeddingInfo.textContent = newProvider === 'openai' ? t('ui.usesEmbedding') : t('ui.localEmbeddingInfo');
                    }
                    if (modelDescription) {
                        modelDescription.textContent = getModelDescription(newProvider);
                    }
                    // Show/hide token and cost rows based on provider
                    if (tokensRow) {
                        tokensRow.style.display = newProvider === 'openai' ? 'flex' : 'none';
                    }
                    if (costRow) {
                        costRow.style.display = newProvider === 'openai' ? 'flex' : 'none';
                    }
                    
                    // Only save again if provider didn't change (otherwise already saved above)
                    if (oldProvider === newProvider) {
                        await saveProfileSettings(profileId);
                    }
                    updateApiKeyWarning(profileId);
                    
                    // Refresh stats to show cleared database
                    const newStats = await window.api.getStats(profileId);
                    profileStats.set(profileId, newStats);
                    updateStats(newStats);
                });
            }
            
            if (selectFolderBtn) {
                selectFolderBtn.addEventListener('click', () => selectFolder(profileId));
                selectFolderBtn.textContent = t('profile.selectFolder');
            }
            
            if (selectDatabaseBtn) {
                selectDatabaseBtn.addEventListener('click', () => selectDatabase(profileId));
                selectDatabaseBtn.textContent = t('profile.selectDatabase');
            }
            
            if (browseDbBtn) {
                browseDbBtn.addEventListener('click', () => openBrowser(profileId));
            }
            
            if (startBtn) {
                startBtn.addEventListener('click', () => toggleWatching(profileId));
            }
        }

        async function selectFolder(profileId) {
            const folder = await window.api.selectFolder();
            if (folder) {
                document.getElementById(`folderPath-${profileId}`).textContent = folder;
                document.getElementById(`folderPath-${profileId}`).classList.add('has-value');
                await window.api.updateProfile(profileId, { watchedFolder: folder });
            } else {
                // Update display text if cancelled
                const folderPathEl = document.getElementById(`folderPath-${profileId}`);
                if (folderPathEl && !folderPathEl.textContent) {
                    folderPathEl.textContent = t('ui.noFolderSelected');
                    folderPathEl.classList.remove('has-value');
                }
            }
        }

        async function selectDatabase(profileId) {
            const dbPath = await window.api.selectDatabase();
            if (dbPath) {
                document.getElementById(`databasePath-${profileId}`).textContent = dbPath;
                document.getElementById(`databasePath-${profileId}`).classList.add('has-value');
                await window.api.updateProfile(profileId, { databasePath: dbPath });
            } else {
                // Update display text if cancelled
                const dbPathEl = document.getElementById(`databasePath-${profileId}`);
                if (dbPathEl && !dbPathEl.textContent) {
                    dbPathEl.textContent = t('ui.noDatabaseSelected');
                    dbPathEl.classList.remove('has-value');
                }
            }
        }

        async function saveProfileSettings(profileId) {
            const profile = profiles.find(p => p.id === profileId);
            if (!profile) return;

            const folderPathEl = document.getElementById(`folderPath-${profileId}`);
            const dbPathEl = document.getElementById(`databasePath-${profileId}`);
            const embeddingProviderEl = document.getElementById(`embeddingProvider-${profileId}`);

            // Collect selected extensions from checkboxes
            const extensionCheckboxes = document.querySelectorAll(`#extensionsSelector-${profileId} input[type="checkbox"]:checked`);
            const selectedExtensions = Array.from(extensionCheckboxes).map(cb => cb.value).join(',');

            const updates = {
                watchedFolder: (folderPathEl.textContent === t('ui.noFolderSelected')) ? '' : folderPathEl.textContent,
                databasePath: (dbPathEl.textContent === t('ui.noDatabaseSelected')) ? '' : dbPathEl.textContent,
                openAIApiKey: document.getElementById(`apiKey-${profileId}`).value,
                fileExtensions: selectedExtensions,
                recursive: document.getElementById(`recursive-${profileId}`).checked,
                embeddingProvider: embeddingProviderEl?.value || 'local-e5-large'
            };

            await window.api.updateProfile(profileId, updates);

            // Update local profile data
            Object.assign(profile, updates);
        }

        async function toggleWatching(profileId) {
            const btn = document.getElementById(`startBtn-${profileId}`);
            const originalText = btn.textContent;
            
            btn.disabled = true;
            const stats = profileStats.get(profileId) || { isSyncing: false };
            btn.textContent = stats.isSyncing ? t('ui.stopping') : t('ui.syncing');
            
            try {
                await saveProfileSettings(profileId);
                
                if (stats.isSyncing) {
                    await window.api.stopWatching(profileId);
                    // Immediately switch to Start button after stopping
                    btn.disabled = false;
                    btn.textContent = t('ui.startSyncing');
                    btn.className = 'btn-primary';
                    document.getElementById('statusDot')?.classList.remove('active');
                    document.getElementById('statusText').textContent = t('tray.notSyncing');
                    // Update local stats
                    const currentStats = profileStats.get(profileId) || {};
                    profileStats.set(profileId, { ...currentStats, isSyncing: false });
                    renderTabs();
                    updateOverallStatus();
                } else {
                    const result = await window.api.startWatching(profileId);
                    if (!result.success) {
                        alert('Error: ' + result.error);
                        btn.disabled = false;
                        btn.textContent = originalText;
                        updateApiKeyWarning(profileId);
                        return;
                    }
                    // Immediately switch to Stop button after successful start
                    btn.disabled = false;
                    btn.textContent = t('ui.stopSync');
                    btn.className = 'btn-danger';
                    document.getElementById('statusDot')?.classList.add('active');
                    document.getElementById('statusText').textContent = t('ui.syncing');
                    // Update local stats
                    const currentStats = profileStats.get(profileId) || {};
                    profileStats.set(profileId, { ...currentStats, isSyncing: true });
                    renderTabs();
                    updateOverallStatus();
                }
            } catch (error) {
                btn.disabled = false;
                btn.textContent = originalText;
                updateApiKeyWarning(profileId);
                alert('Error: ' + error.message);
            }
        }

        function updateStats(stats) {
            profileStats.set(stats.profileId, stats);
            
            if (stats.profileId === activeProfileId) {
                const btn = document.getElementById(`startBtn-${stats.profileId}`);
                if (btn) {
                    document.getElementById(`statusDot`).classList.toggle('active', stats.isSyncing);
                    document.getElementById(`statusText`).textContent = stats.isSyncing ? t('ui.syncing') : t('tray.notSyncing');
                    btn.textContent = stats.isSyncing ? t('ui.stopSync') : t('ui.startSyncing');
                    btn.className = stats.isSyncing ? 'btn-danger' : 'btn-primary';
                    btn.disabled = false;
                    
                    document.getElementById(`trackedFiles-${stats.profileId}`).textContent = stats.trackedFiles;
                    document.getElementById(`totalChunks-${stats.profileId}`).textContent = stats.totalChunks;
                    
                    // Update token/cost stats (only visible for OpenAI)
                    const isOpenAI = stats.embeddingProvider === 'openai';
                    const tokensRow = document.getElementById(`tokensRow-${stats.profileId}`);
                    const costRow = document.getElementById(`costRow-${stats.profileId}`);
                    if (tokensRow) tokensRow.style.display = isOpenAI ? 'flex' : 'none';
                    if (costRow) costRow.style.display = isOpenAI ? 'flex' : 'none';
                    
                    const tokensEl = document.getElementById(`totalTokens-${stats.profileId}`);
                    if (tokensEl) tokensEl.textContent = (stats.totalTokens || 0).toLocaleString();
                    const costEl = document.getElementById(`totalCost-${stats.profileId}`);
                    if (costEl) costEl.textContent = `$${(stats.totalCost || 0).toFixed(4)}`;
                    
                    // Update sync progress indicator
                    const syncProgressCard = document.getElementById(`syncProgressCard-${stats.profileId}`);
                    const syncProgressText = document.getElementById(`syncProgressText-${stats.profileId}`);
                    const syncProgressBar = document.getElementById(`syncProgressBar-${stats.profileId}`);
                    const syncProgressPercent = document.getElementById(`syncProgressPercent-${stats.profileId}`);
                    
                    if (syncProgressCard && syncProgressText && syncProgressBar && syncProgressPercent) {
                        const progress = stats.syncProgress || { filesProcessed: 0, totalFiles: 0 };
                        const filesProcessed = progress.filesProcessed || 0;
                        const totalFiles = progress.totalFiles || 0;
                        
                        if (stats.isSyncing && totalFiles > 0) {
                            syncProgressCard.style.display = 'block';
                            syncProgressText.textContent = `${filesProcessed} / ${totalFiles}`;
                            const percent = totalFiles > 0 ? Math.round((filesProcessed / totalFiles) * 100) : 0;
                            syncProgressBar.style.width = `${percent}%`;
                            syncProgressPercent.textContent = `${percent}%`;
                        } else {
                            syncProgressCard.style.display = 'none';
                        }
                    }
                }
            }
            
            // Update tab status
            renderTabs();
            updateOverallStatus();
            updateApiKeyWarning(stats.profileId);
        }

        function updateStatsAll(allStats) {
            for (const stats of allStats) {
                profileStats.set(stats.profileId, stats);
            }
            renderTabs();
            updateOverallStatus();
            
            // Only update active profile if translations are loaded
            if (activeProfileId && Object.keys(translations).length > 0) {
                const stats = profileStats.get(activeProfileId);
                if (stats) {
                    updateStats(stats);
                }
            }
        }

        function updateOverallStatus() {
            let syncingCount = 0;
            let totalFiles = 0;
            let totalChunks = 0;
            
            for (const stats of profileStats.values()) {
                if (stats.isSyncing) syncingCount++;
                totalFiles += stats.trackedFiles || 0;
                totalChunks += stats.totalChunks || 0;
            }
            
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (syncingCount > 0) {
                statusDot.classList.add('active');
                statusText.textContent = t('tray.syncing', { count: syncingCount });
            } else {
                statusDot.classList.remove('active');
                statusText.textContent = t('tray.notSyncing');
            }
        }

        function updateApiKeyWarning(profileId) {
            if (profileId !== activeProfileId) return;
            
            const embeddingProvider = document.getElementById(`embeddingProvider-${profileId}`)?.value || 'local-e5-large';
            const apiKey = document.getElementById(`apiKey-${profileId}`)?.value || '';
            const hasApiKey = apiKey && apiKey.trim().length > 0;
            const warning = document.getElementById(`apiKeyWarning-${profileId}`);
            
            // Only show warning if using OpenAI and no API key
            const needsApiKey = embeddingProvider === 'openai' && !hasApiKey;
            
            if (warning) {
                warning.style.display = needsApiKey ? 'block' : 'none';
                if (needsApiKey) {
                    warning.textContent = t('ui.apiKeyRequired');
                }
            }
            
            const startBtn = document.getElementById(`startBtn-${profileId}`);
            if (startBtn) {
                const stats = profileStats.get(profileId) || { isSyncing: false };
                if (!stats.isSyncing) {
                    // Only disable if using OpenAI without API key
                    startBtn.disabled = needsApiKey;
                    if (needsApiKey) {
                        startBtn.title = t('ui.apiKeyRequired');
                    } else {
                        startBtn.title = '';
                    }
                }
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Listen for stats updates from main process
        window.api.onStatsUpdate(updateStats);
        window.api.onStatsUpdateAll(updateStatsAll);

        // Listen for model download progress
        window.api.onModelDownloadProgress((data) => {
            const { profileId, status, percent, modelName } = data;
            
            const progressCard = document.getElementById(`downloadProgress-${profileId}`);
            const progressBar = document.getElementById(`downloadProgressBar-${profileId}`);
            const progressText = document.getElementById(`downloadProgressText-${profileId}`);
            const modelNameEl = document.getElementById(`downloadModelName-${profileId}`);
            
            if (!progressCard) return;
            
            if (status === 'downloading') {
                // Only show progress card when actually downloading
                progressCard.style.display = 'block';
                if (modelNameEl) modelNameEl.textContent = modelName || '';
                if (progressBar) progressBar.style.width = `${percent || 0}%`;
                if (progressText) {
                    progressText.textContent = `${t('ui.downloading')}... ${percent || 0}%`;
                }
            } else if (status === 'ready') {
                // Hide the progress card when model is ready
                progressCard.style.display = 'none';
            }
        });

        // Listen for API key errors
        window.api.onApiKeyError((data) => {
            const { profileId, message } = data;
            
            if (profileId === activeProfileId) {
                const apiKeyInput = document.getElementById(`apiKey-${profileId}`);
                if (apiKeyInput) {
                    apiKeyInput.value = '';
                    apiKeyInput.classList.add('error');
                    
                    const warning = document.getElementById(`apiKeyWarning-${profileId}`);
                    if (warning) {
                        warning.textContent = message;
                        warning.style.display = 'block';
                        warning.classList.add('error');
                    }
                    
                    updateApiKeyWarning(profileId);
                }
            }
            
            alert(`API Key Error (${profiles.find(p => p.id === profileId)?.name || 'Profile'}): ${message}`);
        });

        // Listen for profile switch from tray
        window.api.onSwitchProfile(async (profileId) => {
            await switchProfile(profileId);
        });

        // Function to register language changed listener
        function registerLanguageChangedListener() {
            if (!window.api || !window.api.onLanguageChanged) {
                return false;
            }
            
            try {
                window.api.onLanguageChanged(async (locale) => {
                    currentLanguage = locale;
                    const langSelect = document.getElementById('languageSelect');
                    if (langSelect) {
                        langSelect.value = locale;
                    }
                    const loaded = await loadTranslations(locale);
                    if (loaded) {
                        updateUI();
                    }
                });
                return true;
            } catch (error) {
                return false;
            }
        }

        // Set up language selector event listener
        function setupLanguageSelector() {
            const langSelect = document.getElementById('languageSelect');
            if (langSelect) {
                // Remove any existing listeners by cloning the element
                const newSelect = langSelect.cloneNode(true);
                langSelect.parentNode.replaceChild(newSelect, langSelect);
                
                // Add the event listener to the new element
                const newLangSelect = document.getElementById('languageSelect');
                if (newLangSelect) {
                    newLangSelect.addEventListener('change', (e) => {
                        changeLanguage(e.target.value);
                    });
                }
            }
        }

        // MCP Server functions
        async function toggleMcpServer() {
            if (!activeProfileId) {
                alert(t('ui.noActiveProfile'));
                return;
            }
            
            // Get current status first
            const currentStatus = await window.api.getMcpStatus(activeProfileId);
            
            if (currentStatus.running) {
                const result = await window.api.stopMcpServer(activeProfileId);
                if (result.success) {
                    updateMcpStatus(false);
                } else {
                    alert(t('ui.errorStoppingMcp') + ': ' + result.error);
                    // Reload status to ensure UI is correct
                    await loadMcpStatus();
                }
            } else {
                const result = await window.api.startMcpServer(activeProfileId);
                if (result.success) {
                    updateMcpStatus(true, result.port);
                } else {
                    alert(t('ui.errorStartingMcp') + ': ' + result.error);
                    // Reload status to ensure UI is correct
                    const status = await window.api.getMcpStatus(activeProfileId);
                    updateMcpStatus(status.running, status.port);
                    // Force enable port input - server definitely didn't start if we got an error
                    const portInput = document.getElementById('mcpPort');
                    if (portInput) {
                        portInput.disabled = false;
                        portInput.removeAttribute('disabled');
                    }
                }
            }
        }


        function updateMcpStatus(running, port = null) {
            mcpRunning = running;
            const btn = document.getElementById('mcpToggleBtn');
            const status = document.getElementById('mcpStatus');
            const configureBtn = document.getElementById('mcpConfigureBtn');
            const portInput = document.getElementById('mcpPort');

            if (running) {
                btn.textContent = t('mcp.stopServer');
                btn.className = 'btn-danger';
                status.innerHTML = `<span style="color: #34c759;">‚óè ${t('mcp.status.running', { port: port || (portInput ? portInput.value : '') })}</span>`;
                configureBtn.style.display = 'block';
                if (portInput) {
                    portInput.disabled = true;
                }
            } else {
                btn.textContent = t('mcp.startServer');
                btn.className = 'btn-secondary';
                status.textContent = t('mcp.status.stopped');
                configureBtn.style.display = 'none';
                // Always enable port input when server is not running
                if (portInput) {
                    portInput.disabled = false;
                    // Force enable in case it was disabled by CSS or other code
                    portInput.removeAttribute('disabled');
                }
            }
        }

        async function loadMcpStatus() {
            if (!activeProfileId) return;
            
            const status = await window.api.getMcpStatus(activeProfileId);
            const profile = profiles.find(p => p.id === activeProfileId);
            const mcpPortInput = document.getElementById('mcpPort');
            
            if (mcpPortInput && profile) {
                // Store the current value
                const currentValue = mcpPortInput.value;
                const wasDisabled = mcpPortInput.disabled;
                
                // Remove old listener if exists and add new one
                const newInput = mcpPortInput.cloneNode(true);
                mcpPortInput.parentNode.replaceChild(newInput, mcpPortInput);
                const portInput = document.getElementById('mcpPort');
                
                if (portInput) {
                    // Set value and disabled state based on CURRENT profile's status
                    portInput.value = profile.mcpServerPort || 3333;
                    portInput.disabled = status.running; // Enable/disable based on THIS profile's server status
                    
                    portInput.addEventListener('change', async () => {
                        // Only save the port if server is not running - no validation here
                        // Validation will happen when user tries to start the server
                        const currentStatus = await window.api.getMcpStatus(activeProfileId);
                        if (!currentStatus.running && activeProfileId) {
                            const port = parseInt(portInput.value) || 3333;
                            // Just save the port value - no validation, no errors
                            // Port conflicts will be checked when starting the server
                            const result = await window.api.updateMcpPort(activeProfileId, port);
                            if (result.success) {
                                // Update local profile data
                                const currentProfile = profiles.find(p => p.id === activeProfileId);
                                if (currentProfile) {
                                    currentProfile.mcpServerPort = port;
                                }
                            }
                            // Don't show errors here - allow user to set any port
                            // Errors will be shown when they try to start the server
                        } else if (currentStatus.running) {
                            // Server is running, restore port value
                            const currentProfile = profiles.find(p => p.id === activeProfileId);
                            if (currentProfile) {
                                portInput.value = currentProfile.mcpServerPort || 3333;
                            }
                            alert(t('ui.cannotChangePortWhileRunning'));
                        }
                    });
                }
            }
            updateMcpStatus(status.running, status.port);
        }

        // MCP Config modal functions
        function openMcpConfig() {
            const port = document.getElementById('mcpPort').value;
            const url = `http://localhost:${port}/mcp`;
            
            // Generate configs for each client
            const cursorConfig = {
                mcpServers: {
                    "Docs4ai": {
                        url: url
                    }
                }
            };
            
            const vscodeConfig = {
                "mcp.servers": {
                    "Docs4ai": {
                        url: url,
                        transport: "streamable-http"
                    }
                }
            };
            
            const claudeConfig = {
                mcpServers: {
                    "Docs4ai": {
                        url: url
                    }
                }
            };
            
            const chatgptConfig = {
                servers: [{
                    name: "Docs4ai",
                    url: url,
                    type: "streamable-http"
                }]
            };
            
            // Set config content
            document.getElementById('cursorConfig').textContent = JSON.stringify(cursorConfig, null, 2);
            document.getElementById('vscodeConfig').textContent = JSON.stringify(vscodeConfig, null, 2);
            document.getElementById('claudeConfig').textContent = JSON.stringify(claudeConfig, null, 2);
            document.getElementById('chatgptConfig').textContent = JSON.stringify(chatgptConfig, null, 2);
            document.getElementById('mcpUrl').textContent = url;
            
            // Show modal
            document.getElementById('mcpConfigModal').classList.add('active');
            switchMcpTab('cursor');
        }
        
        function closeMcpConfig() {
            document.getElementById('mcpConfigModal').classList.remove('active');
        }
        
        function switchMcpTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.mcp-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === tab);
            });
            
            // Update panels
            document.querySelectorAll('.mcp-panel').forEach(p => {
                p.style.display = 'none';
            });
            document.getElementById(`panel-${tab}`).style.display = 'block';
        }
        
        function copyConfig(type) {
            const configEl = document.getElementById(`${type}Config`);
            navigator.clipboard.writeText(configEl.textContent).then(() => {
                const btn = configEl.parentElement.querySelector('.mcp-copy-btn');
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = originalText, 1500);
            });
        }
        
        function copyText(elementId) {
            const el = document.getElementById(elementId);
            navigator.clipboard.writeText(el.textContent).then(() => {
                const btn = el.parentElement.querySelector('.mcp-copy-btn');
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = originalText, 1500);
            });
        }

        // Browser modal functions
        let currentView = 'files'; // 'files' or 'chunks'
        let selectedFilePath = null;
        let savedTreeHtml = null; // Save tree state when viewing chunks
        let savedTreeScroll = 0;
        let browserProfileId = null;

        async function openBrowser(profileId) {
            browserProfileId = profileId || activeProfileId;
            document.getElementById('browserModal').classList.add('active');
            currentView = 'files';
            savedTreeHtml = null; // Reset saved state when opening
            await showFileList(true); // Force rebuild on open
        }

        function closeBrowser() {
            document.getElementById('browserModal').classList.remove('active');
            savedTreeHtml = null; // Clear saved state
        }

        async function showFileList(forceRebuild = false) {
            currentView = 'files';
            const profileId = browserProfileId || activeProfileId;
            const profile = profiles.find(p => p.id === profileId);
            document.getElementById('modalTitle').textContent = `üìÇ ${t('ui.browseDatabaseTitle')} - ${profile?.name || t('profile.name')}`;
            const body = document.getElementById('modalBody');
            
            // If we have saved tree HTML, restore it instead of rebuilding
            if (!forceRebuild && savedTreeHtml) {
                body.innerHTML = savedTreeHtml;
                body.scrollTop = savedTreeScroll;
                return;
            }
            
            const files = await window.api.getFiles(profileId);
            
            if (files.length === 0) {
                body.innerHTML = `<div class="empty-state">${t('ui.noFilesInDatabase')}</div>`;
                return;
            }
            
            // Use the configured watched folder as base path
            const basePath = profile?.watchedFolder || findCommonBasePath(files.map(f => f.path));
            
            // Build tree structure relative to base path
            const tree = buildFileTree(files, basePath);
            
            // Show base path as header
            let html = `<div style="font-size: 12px; color: #86868b; margin-bottom: 12px; padding: 8px; background: #f5f5f7; border-radius: 6px;">üìÅ ${basePath}</div>`;
            html += renderTree(tree);
            body.innerHTML = html;
        }

        function findCommonBasePath(paths) {
            if (paths.length === 0) return '';
            if (paths.length === 1) {
                // Return directory of single file
                const parts = paths[0].split('/');
                parts.pop();
                return parts.join('/');
            }
            
            const splitPaths = paths.map(p => p.split('/'));
            const minLength = Math.min(...splitPaths.map(p => p.length));
            
            let commonParts = [];
            for (let i = 0; i < minLength - 1; i++) { // -1 to exclude filename
                const part = splitPaths[0][i];
                if (splitPaths.every(p => p[i] === part)) {
                    commonParts.push(part);
                } else {
                    break;
                }
            }
            
            return commonParts.join('/');
        }

        function buildFileTree(files, basePath) {
            const root = { name: 'root', children: {}, files: [], totalChunks: 0 };
            const baseDepth = basePath.split('/').filter(p => p).length;
            
            for (const file of files) {
                const parts = file.path.split('/').filter(p => p);
                // Skip the common base path parts
                const relativeParts = parts.slice(baseDepth);
                
                let current = root;
                
                // Navigate/create directories
                for (let i = 0; i < relativeParts.length - 1; i++) {
                    const part = relativeParts[i];
                    if (!current.children[part]) {
                        current.children[part] = { name: part, children: {}, files: [], totalChunks: 0 };
                    }
                    current = current.children[part];
                    current.totalChunks += file.chunkCount;
                }
                
                // Add file to current directory
                current.files.push({
                    name: relativeParts[relativeParts.length - 1],
                    path: file.path,
                    chunkCount: file.chunkCount
                });
                root.totalChunks += file.chunkCount;
            }
            
            return root;
        }

        function renderTree(node, depth = 0) {
            let html = '';
            
            // Sort directories first, then files
            const dirs = Object.keys(node.children).sort();
            const files = node.files.sort((a, b) => a.name.localeCompare(b.name));
            
            if (depth === 0) {
                html = '<ul class="tree">';
            }
            
            // Render directories
            for (const dirName of dirs) {
                const dir = node.children[dirName];
                const dirId = 'dir-' + Math.random().toString(36).substr(2, 9);
                const fileCount = countFiles(dir);
                
                html += `
                    <li class="tree-item">
                        <div class="tree-node" onclick="toggleDir('${dirId}')">
                            <span class="tree-toggle" id="toggle-${dirId}">‚ñ∂</span>
                            <span class="tree-icon">üìÅ</span>
                            <span class="tree-label">${escapeHtml(dirName)}</span>
                            <span class="tree-count">${fileCount} files, ${dir.totalChunks} chunks</span>
                        </div>
                        <ul class="tree-children" id="${dirId}">
                            ${renderTree(dir, depth + 1)}
                        </ul>
                    </li>
                `;
            }
            
            // Render files
            for (const file of files) {
                // Use base64 encoding for safe handling of special characters in paths
                const encodedPath = btoa(encodeURIComponent(file.path));
                html += `
                    <li class="tree-item">
                        <div class="tree-node file" onclick="showChunksEncoded('${encodedPath}')">
                            <span class="tree-toggle"></span>
                            <span class="tree-icon">üìÑ</span>
                            <span class="tree-label">${escapeHtml(file.name)}</span>
                            <span class="tree-count">(${file.chunkCount})</span>
                        </div>
                    </li>
                `;
            }
            
            if (depth === 0) {
                html += '</ul>';
            }
            
            return html;
        }

        function countFiles(node) {
            let count = node.files.length;
            for (const child of Object.values(node.children)) {
                count += countFiles(child);
            }
            return count;
        }

        function toggleDir(dirId) {
            const children = document.getElementById(dirId);
            const toggle = document.getElementById('toggle-' + dirId);
            
            if (children.classList.contains('expanded')) {
                children.classList.remove('expanded');
                toggle.textContent = '‚ñ∂';
            } else {
                children.classList.add('expanded');
                toggle.textContent = '‚ñº';
            }
        }

        function showChunksEncoded(encodedPath) {
            // Decode base64 + URI encoded path
            const filePath = decodeURIComponent(atob(encodedPath));
            showChunks(filePath);
        }

        async function showChunks(filePath) {
            const body = document.getElementById('modalBody');
            const profileId = browserProfileId || activeProfileId;
            
            // Save current tree state before switching to chunks
            savedTreeHtml = body.innerHTML;
            savedTreeScroll = body.scrollTop;
            
            currentView = 'chunks';
            selectedFilePath = filePath;
            const fileName = filePath.split('/').pop();
            document.getElementById('modalTitle').textContent = `üìÑ ${fileName}`;
            
            const chunks = await window.api.getChunks(profileId, filePath);
            
            let html = `<button class="back-btn" onclick="showFileList()">${t('ui.backToFiles')}</button>`;
            
            if (chunks.length === 0) {
                html += `<div class="empty-state">${t('ui.noChunksFound')}</div>`;
                body.innerHTML = html;
                return;
            }
            
            html += `<div class="chunks-header">${chunks.length} ${t('ui.chunks')}</div>`;
            html += '<div class="chunks-list">';
            
            for (const chunk of chunks) {
                html += `
                    <div class="chunk-item">
                        <div class="chunk-header">
                            <span class="chunk-section">${chunk.section || 'No section'}</span>
                            <span>Chunk ${chunk.chunkIndex + 1}</span>
                        </div>
                        <div class="chunk-content">${escapeHtml(chunk.content)}</div>
                    </div>
                `;
            }
            
            html += '</div>';
            body.innerHTML = html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Close modal on overlay click
        document.getElementById('browserModal').addEventListener('click', (e) => {
            if (e.target.id === 'browserModal') {
                closeBrowser();
            }
        });

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('browserModal').classList.contains('active')) {
                closeBrowser();
            }
        });

        // Language switching and translations
        let currentLanguage = 'en';
        let translations = {};
        
        // Simple translation function
        function getModelDescription(provider) {
            const descriptions = {
                'local-minilm': t('ui.minilmDescription'),
                'local-e5': t('ui.e5Description'),
                'local-e5-large': t('ui.e5LargeDescription'),
                'local-qwen': t('ui.e5Description'), // Fallback for old provider
                'openai': t('ui.openaiDescription')
            };
            return descriptions[provider] || '';
        }

        function t(key, options = {}) {
            const keys = key.split('.');
            let value = translations;
            for (const k of keys) {
                value = value?.[k];
                if (value === undefined) return key;
            }
            
            if (typeof value !== 'string') return key;
            
            // Simple interpolation
            if (options && typeof value === 'string') {
                return value.replace(/\{\{(\w+)\}\}/g, (match, key) => {
                    return options[key] !== undefined ? options[key] : match;
                });
            }
            
            return value;
        }
        
        async function loadTranslations(locale) {
            try {
                translations = await window.api.getTranslations(locale);
                return true;
            } catch (error) {
                return false;
            }
        }
        
        async function initLanguage() {
            try {
                currentLanguage = await window.api.getLanguage();
                const langSelect = document.getElementById('languageSelect');
                if (langSelect) {
                    langSelect.value = currentLanguage;
                }
                const loaded = await loadTranslations(currentLanguage);
                if (loaded) {
                    updateUI();
                }
            } catch (error) {
                // Silently handle errors during initialization
            }
        }

        async function changeLanguage(locale) {
            try {
                const result = await window.api.setLanguage(locale);
                
                if (result && result.success) {
                    // The main process will send a 'language-changed' event
                    // which will trigger onLanguageChanged handler
                    // But we also update immediately here for responsiveness
                    currentLanguage = locale;
                    const loaded = await loadTranslations(locale);
                    if (loaded) {
                        updateUI(); // Update all UI elements
                    }
                } else {
                    const errorMsg = result?.error || 'Unknown error';
                    alert(t('common.error') + ': ' + errorMsg);
                }
            } catch (error) {
                alert(t('common.error') + ': ' + (error.message || t('common.errorChangingLanguage')));
            }
        }
        
        // Update all UI elements with translations
        function updateUI() {
            // Don't update if translations aren't loaded yet
            if (Object.keys(translations).length === 0) {
                return;
            }
            
            // Update header status
            updateOverallStatus();
            
            // Update MCP Server section
            const mcpTitle = document.querySelector('.card .card-title');
            if (mcpTitle && mcpTitle.textContent.includes('MCP Server')) {
                mcpTitle.textContent = `üåê ${t('mcp.title')}`;
            }
            
            const mcpPortLabel = document.querySelector('label[for="mcpPort"]');
            if (mcpPortLabel) {
                mcpPortLabel.textContent = t('mcp.port') + ':';
            }
            
            const mcpToggleBtn = document.getElementById('mcpToggleBtn');
            if (mcpToggleBtn) {
                mcpToggleBtn.textContent = mcpRunning ? t('mcp.stopServer') : t('mcp.startServer');
            }
            
            const mcpConfigureBtn = document.getElementById('mcpConfigureBtn');
            if (mcpConfigureBtn && mcpConfigureBtn.textContent.includes('Configure')) {
                mcpConfigureBtn.textContent = t('mcp.configureClients', {});
            }
            
            // Update active profile content
            if (activeProfileId) {
                renderActiveProfile();
            }
        }

        // Initialize - set up event listeners first, then load language, then profiles
        // Wait for window.api to be available before setting up listeners
        function initializeApp() {
            if (typeof window.api === 'undefined') {
                setTimeout(initializeApp, 100);
                return;
            }
            
            // Register language changed listener
            const listenerRegistered = registerLanguageChangedListener();
            if (!listenerRegistered) {
                setTimeout(() => {
                    registerLanguageChangedListener();
                }, 500);
            }
            
            setupLanguageSelector(); // Set up language selector event listener
            initLanguage().then(() => {
                // Wait for translations to load before loading profiles
                loadProfiles();
            });
        }
        
        // Start initialization
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
</body>
</html>
